from .tenants_api import router_tenants
from fastapi import FastAPI, Depends, HTTPException, status, Header, Request
from .version_api import router_version
# --- API key guard (plain typing, no Annotated) ---
def verify_api_key(
    request: Request,  # required first
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
    authorization: str | None = Header(default=None, alias="Authorization"),
):
    expected = os.getenv("SENTINEL_API_KEY")
    if not expected:
        try:
            env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), ".env")
            if os.path.exists(env_path):
                with open(env_path, "r", encoding="utf-8") as f:
                    for line in f:
                        s = line.strip()
                        if not s or s.startswith("#") or "=" not in s:
                            continue
                        k, val = s.split("=",1)
                        if k.strip() == "SENTINEL_API_KEY":
                            expected = val.strip().strip("'").strip('"')
                            break
        except Exception:
            pass

    token = None
    if authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(" ",1)[1].strip()
    elif x_api_key:
        token = x_api_key.strip()

    if not expected or not token or token != expected:
        try:
            client = request.client.host if request and request.client else ""
            write_audit("auth_failed", 401, request.url.path if request else "", request.method if request else "", client, {"reason":"bad or missing key"})
        except Exception:
            pass
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized")
    return True
# --- API key guard (ordered) ---
def verify_api_key(
    request: Request,  # required first
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
    authorization: str | None = Header(default=None, alias="Authorization"),
):
    expected = os.getenv("SENTINEL_API_KEY")
    if not expected:
        try:
            env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), ".env")
            if os.path.exists(env_path):
                with open(env_path, "r", encoding="utf-8") as f:
                    for line in f:
                        s = line.strip()
                        if not s or s.startswith("#") or "=" not in s:
                            continue
                        k, val = s.split("=",1)
                        if k.strip() == "SENTINEL_API_KEY":
                            expected = val.strip().strip("'").strip('"')
                            break
        except Exception:
            pass

    token = None
    if authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(" ",1)[1].strip()
    elif x_api_key:
        token = x_api_key.strip()

    if not expected or not token or token != expected:
        try:
            client = request.client.host if request and request.client else ""
            write_audit("auth_failed", 401, request.url.path if request else "", request.method if request else "", client, {"reason":"bad or missing key"})
        except Exception:
            pass
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized")
    return True
# --- API key guard (ordered, Annotated) ---
def verify_api_key(
    request: Request,  # required first
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
    authorization: str | None = Header(default=None, alias="Authorization"),
):
    expected = os.getenv("SENTINEL_API_KEY")
    if not expected:
        try:
            env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), ".env")
            if os.path.exists(env_path):
                with open(env_path, "r", encoding="utf-8") as f:
                    for line in f:
                        s = line.strip()
                        if not s or s.startswith("#") or "=" not in s:
                            continue
                        k, val = s.split("=",1)
                        if k.strip() == "SENTINEL_API_KEY":
                            expected = val.strip().strip("'").strip('"')
                            break
        except Exception:
            pass

    token = None
    if authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(" ",1)[1].strip()
    elif x_api_key:
        token = x_api_key.strip()

    if not expected or not token or token != expected:
        try:
            client = request.client.host if request and request.client else ""
            write_audit("auth_failed", 401, request.url.path if request else "", request.method if request else "", client, {"reason":"bad or missing key"})
        except Exception:
            pass
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized")
    return True
import os
from datetime import datetime
from sqlalchemy import text
from .db import get_engine

# -------- Audit (local JSONL) --------
def _audit_path() -> str:
    base = os.path.join(os.path.dirname(os.path.dirname(__file__)), "ops", "logs")
    os.makedirs(base, exist_ok=True)
    day = datetime.utcnow().strftime("%Y%m%d")
    return os.path.join(base, f"audit-{day}.jsonl")

def write_audit(event: str, status_code: int, path: str, method: str, client: str = "", detail: dict | None = None):
    try:
        rec = {
            "ts": datetime.utcnow().isoformat() + "Z",
            "event": event,
            "status": status_code,
            "path": path,
            "method": method,
            "client": client,
        }
        if detail:
            rec["detail"] = detail
        with open(_audit_path(), "a", encoding="utf-8") as f:
            import json
            f.write(json.dumps(rec, ensure_ascii=False) + "\n")
    except Exception:
        pass

# --- Sentinel request metrics + API-key middleware (injected) ---
from typing import Optional
import os, re
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request as StarletteRequest
from starlette.responses import Response as StarletteResponse, PlainTextResponse
BOOT_TIME = datetime.utcnow()

_SENTINEL_REQ_COUNTS = {}
_HEALTH_ALLOW = ("/healthz", "/healthz/live", "/healthz/ready")

def _inc_metric(path: str, status: int):
    key = (path, status)
    _SENTINEL_REQ_COUNTS[key] = _SENTINEL_REQ_COUNTS.get(key, 0) + 1

def _extract_bearer(token: Optional[str]) -> Optional[str]:
    if not token:
        return None
    m = re.match(r"Bearer\s+(.+)", token, flags=re.IGNORECASE)
    return m.group(1) if m else None

class ApiKeyMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: StarletteRequest, call_next):
        path = request.url.path
        if not any(path == h or path.startswith(h + "/") for h in _HEALTH_ALLOW):
            env_key = os.getenv("SENTINEL_API_KEY") or ""
            x_api   = request.headers.get("X-API-Key")
            auth    = _extract_bearer(request.headers.get("Authorization"))
            supplied = x_api or auth
            if not env_key or supplied != env_key:
                _inc_metric(path, 401)
                return PlainTextResponse("Unauthorized", status_code=401)
        resp: StarletteResponse = await call_next(request)
        try: _inc_metric(path, int(resp.status_code))
        except Exception: pass
        return resp
app = FastAPI()
app.add_middleware(ApiKeyMiddleware)
app.include_router(router_version)
app.include_router(router_tenants)
def _env_api_key() -> str | None:
    v = os.getenv("SENTINEL_API_KEY")
    if v:
        return v
    try:
        env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), ".env")
        if os.path.exists(env_path):
            with open(env_path, "r", encoding="utf-8") as f:
                for line in f:
                    s = line.strip()
                    if not s or s.startswith("#") or "=" not in s:
                        continue
                    k, val = s.split("=",1)
                    if k.strip() == "SENTINEL_API_KEY":
                        return val.strip().strip("'").strip('"')
    except Exception:
        pass
    return None

# -------- Guard (Request REQUIRED; no Optional/Union) --------
def verify_api_key(
    request: Request,
    x_api_key: str | None = Header(default=None, alias="X-API-Key"),
    authorization: str | None = Header(default=None, alias="Authorization"),
):
    expected = _env_api_key()
    token = None
    if authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(" ",1)[1].strip()
    elif x_api_key:
        token = x_api_key.strip()
    if not expected or not token or token != expected:
        try:
            client = request.client.host if request and request.client else ""
            write_audit("auth_failed", 401, request.url.path if request else "", request.method if request else "", client, {"reason":"bad or missing key"})
        except Exception:
            pass
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized")
    return True

# -------- Health --------
@app.get("/healthz")
def healthz():
    return {"status":"ok"}

@app.get("/healthz/live")
def health_live():
    return {"live": True}

@app.get("/healthz/ready")
def health_ready():
    try:
        e = get_engine()
        with e.connect() as conn:
            conn.execute(text("SELECT 1"))
        return {"ready": True}
    except Exception as ex:
        raise HTTPException(status_code=503, detail=f"not ready: {ex}")

# -------- Audit Middleware --------
@app.middleware("http")
async def _audit_middleware(request: Request, call_next):
    resp = None
    try:
        resp = await call_next(request)
        return resp
    finally:
        try:
            path = str(request.url.path)
            if path.startswith("/tenants/") and path.endswith("/enable"):
                client = request.client.host if request and request.client else ""
                status_code = resp.status_code if resp else 500
                write_audit("team_enable", status_code, path, request.method, client)
        except Exception:
            pass

# -------- Teams endpoints --------
@app.post("/tenants/{tenant_id}/teams/{team}/enable", dependencies=[Depends(verify_api_key)])
def enable_team(tenant_id: int, team: str, enabled: bool = True):
    now = datetime.utcnow().isoformat() + "Z"
    e = get_engine()
    with e.begin() as conn:
        conn.execute(
            text("""
                INSERT INTO teams (tenant_id, name, enabled, updated_at)
                VALUES (:tid, :name, :enabled, :ts)
                ON CONFLICT(tenant_id, name) DO UPDATE
                   SET enabled=excluded.enabled, updated_at=excluded.updated_at
            """),
            {"tid": tenant_id, "name": team, "enabled": 1 if enabled else 0, "ts": now},
        )
        row = conn.execute(
            text("SELECT id, tenant_id, name, enabled, updated_at FROM teams WHERE tenant_id=:tid AND name=:name"),
            {"tid": tenant_id, "name": team},
        ).mappings().first()
        return {
            "id": row["id"],
            "tenant_id": row["tenant_id"],
            "team": row["name"],
            "enabled": bool(row["enabled"]),
            "updated_at": row["updated_at"],
        }

@app.get("/tenants/{tenant_id}/teams")
def list_teams(tenant_id: int):
    e = get_engine()
    with e.connect() as conn:
        rows = conn.execute(
            text("SELECT id, tenant_id, name, enabled, updated_at FROM teams WHERE tenant_id=:tid ORDER BY name"),
            {"tid": tenant_id},
        ).mappings().all()
        return [
            {"id": r["id"], "tenant_id": r["tenant_id"], "team": r["name"], "enabled": bool(r["enabled"]), "updated_at": r["updated_at"]}
            for r in rows
        ]









from fastapi import Response
@app.get("/metrics")
def metrics() -> Response:
    lines = []
    lines.append("sentinel_up 1")
    epoch = int(BOOT_TIME.timestamp())
    lines.append(f"sentinel_started_at_seconds {epoch}")
    # job queue counters
    try:
        qc = queue_counts()
        for k, v in qc.items():
            lines.append(f'sentinel_jobs_total{{status="{k}"}} {v}')
    except Exception:
        pass
    for (p, s), n in sorted(_SENTINEL_REQ_COUNTS.items()):
        lines.append(f'sentinel_requests_total{{path="{p}",status="{s}"}} {n}')
    body = "\n".join(lines) + "\n"
    return Response(content=body, media_type="text/plain; version=0.0.4")




# === mounted by setup script ===
from fastapi import Depends

      $line = $Matches[0]
      if ($line -notmatch '\bagents\b') { $line += ', agents' }
      if ($line -notmatch '\bjobs\b')   { $line += ', jobs' }
      if ($line -notmatch '\badmin\b')  { $line += ', admin' }
      if ($line -notmatch '\bllm\b')    { $line += ', llm' }
      $line
    
from sentinel_engine.security import guard_api_key

try:
    app.include_router(agents.router, prefix="/agents", tags=["agents"], dependencies=[Depends(guard_api_key)])
    app.include_router(jobs.router,   prefix="/jobs",   tags=["jobs"],   dependencies=[Depends(guard_api_key)])
except Exception as _e:
    # If app not yet defined where this runs, ignore (file executed elsewhere)
    pass

try:
    app.include_router(admin.router,  prefix="/admin", tags=["admin"])
    app.include_router(llm.router,    prefix="/llm",   tags=["llm"])
except Exception:
    pass

