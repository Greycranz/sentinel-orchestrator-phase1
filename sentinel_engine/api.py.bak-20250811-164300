from sqlalchemy import text
from .db import get_engine
from .audit import write_audit
from .config import get_api_key, get_port
from .config import api_key, is_rollback_enabled, set_rollback, audit_log, build_version
from .tenants_api import router_tenants
from . import db
from fastapi import FastAPI, Depends, HTTPException, status, Header, Request, Header

def get_admin_key() -> str:
    return os.getenv("SENTINEL_ADMIN_KEY","")

async def require_admin(x_admin_key: str = Header(default="")):
    key = get_admin_key()
    if key and x_admin_key == key:
        return True
    raise HTTPException(status_code=403, detail="Forbidden")
from .db import create_task, get_task, list_tasks, update_task_status, create_tenant, list_tenants, get_tenant, create_api_key, list_api_keys, list_tenant_teams
from fastapi.responses import HTMLResponse, JSONResponse

def get_admin_key() -> str:
    return os.getenv("SENTINEL_ADMIN_KEY","")

async def require_admin(x_admin_key: str = Header(default="")):
    key = get_admin_key()
    if key and x_admin_key == key:
        return True
    raise HTTPException(status_code=403, detail="Forbidden")
from typing import List
from datetime import datetime
import json, os, secrets

from .models import TaskIn, TaskOut, TenantIn, TenantOut

from .task_queue import notify_new_task
from .integrator import deploy, rollback
from .metrics import tasks_created, tasks_deployed, render_prometheus
from .auth import verify_basic_auth
from .teams_api import router_teams

router = APIRouter()

# ---- merge in Teams CRUD ----
router.include_router(router_teams)

# ---- Tool registry endpoints (so Upgrader can adopt new tools) ----
@router.get("/tools/registry")
def get_tool_registry():
    path = os.path.join(os.path.dirname(__file__), "tool_registry.json")
    if not os.path.exists(path):
        return JSONResponse({"tools": [], "policy": {"accept_only_free": True, "sandbox_required": True}})
    with open(path, "r", encoding="utf-8") as f:
        return JSONResponse(json.load(f))

@router.post("/tools/registry")
def update_tool_registry(payload: dict):
    path = os.path.join(os.path.dirname(__file__), "tool_registry.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2)
    return {"ok": True}

def row_to_taskout(row) -> TaskOut:
    data = None
    if row.get("data"):
        try:
            data = json.loads(row["data"])
        except Exception:
            data = None
    return TaskOut(
        id=row["id"],
        title=row["title"],
        description=row["description"],
        priority=row["priority"],
        requester=row["requester"],
        status=row["status"],
        created_at=datetime.fromisoformat(row["created_at"]),
        updated_at=datetime.fromisoformat(row["updated_at"]),
        tenant_id=row.get("tenant_id"),
        data=data,
    )

def row_to_tenantout(row) -> TenantOut:
    return TenantOut(
        id=row["id"],
        name=row["name"],
        plan=row["plan"],
        safety_mode=row["safety_mode"],
        created_at=datetime.fromisoformat(row["created_at"]),
    )

@router.get("/health")
def health():
    return {"ok": True}

@router.post("/tenants", response_model=TenantOut)
async def create_tenant_endpoint(tenant: TenantIn):
    tid = create_tenant(tenant.name, tenant.plan, tenant.safety_mode)
    row = get_tenant(tid)
    return row_to_tenantout(row)

@router.get("/tenants", response_model=List[TenantOut])
async def list_tenants_endpoint(limit: int = 200):
    rows = list_tenants(limit=limit)
    return [row_to_tenantout(r) for r in rows]

@router.post("/tenants/{tenant_id}/apikeys")
async def create_apikey_endpoint(tenant_id: int, name: str = "default"):
    key = secrets.token_urlsafe(32)
    create_api_key(tenant_id, name, key)
    return {"tenant_id": tenant_id, "name": name, "api_key": key}

@router.get("/tenants/{tenant_id}/apikeys")
async def list_apikeys_endpoint(tenant_id: int):
    return list_api_keys(tenant_id)

@router.post("/tasks", response_model=TaskOut)
async def create_task_endpoint(task: TaskIn):
    task_id = create_task(task.title, task.description, task.priority, task.requester, task.data, task.tenant_id)
    tasks_created.inc()
    await notify_new_task(task_id)
    row = get_task(task_id)
    return row_to_taskout(row)

@router.get("/tasks", response_model=List[TaskOut])
async def list_tasks_endpoint(limit: int = 100):
    rows = list_tasks(limit=limit)
    return [row_to_taskout(r) for r in rows]

@router.get("/tasks/{task_id}", response_model=TaskOut)
async def get_task_endpoint(task_id: int):
    row = get_task(task_id)
    if not row:
        raise HTTPException(status_code=404, detail="Task not found")
    return row_to_taskout(row)

@router.post("/tasks/{task_id}/approve", response_model=TaskOut)
async def approve_task_endpoint(task_id: int):
    row = get_task(task_id)
    if not row:
        raise HTTPException(status_code=404, detail="Task not found")
    if row["status"] != "awaiting_approval":
        raise HTTPException(status_code=400, detail="Task not ready for approval")
    data = json.loads(row["data"]) if row.get("data") else {}
    deploy_log = deploy(task_id, data.get("artifact", {}))
    data["deploy"] = deploy_log
    update_task_status(task_id, "deployed", data_update=data)
    tasks_deployed.inc()
    row = get_task(task_id)
    return row_to_taskout(row)

@router.post("/tasks/{task_id}/rollback")
async def rollback_task_endpoint(task_id: int, reason: str = "manual rollback"):
    row = get_task(task_id)
    if not row:
        raise HTTPException(status_code=404, detail="Task not found")
    data = json.loads(row["data"]) if row.get("data") else {}
    data["rollback"] = rollback(task_id, reason)
    update_task_status(task_id, "rolled_back", data_update=data)
    return {"ok": True, "task_id": task_id, "reason": reason}

@router.get("/ui/approvals", response_class=HTMLResponse)
async def approvals_ui(request: Request):
    import os
    pw = os.environ.get("UI_ADMIN_PASSWORD")
    from .auth import set_ui_password

    if pw and (getattr(set_ui_password, "_initialized", False) is False):
        set_ui_password(pw)
        setattr(set_ui_password, "_initialized", True)
    if pw:
        verify_basic_auth(request)

    rows = list_tasks(limit=200)
    awaiting = [r for r in rows if r["status"] == "awaiting_approval"]
    items = ""
    for r in awaiting:
        t = r.get("tenant_id") or "-"
        items += f"""
        <li>
            <strong>#{r['id']}</strong> [tenant: {t}] â€“ {r['title']}
            <form method="post" action="/tasks/{r['id']}/approve" style="display:inline;">
                <button type="submit">Approve</button>
            </form>
            <form method="post" action="/tasks/{r['id']}/rollback" style="display:inline;margin-left:8px;">
                <button type="submit">Rollback</button>
            </form>
        </li>
        """
    html = f"""
    <html>
      <head><title>Sentinel Approvals</title></head>
      <body>
        <h1>Awaiting Approval</h1>
        <ul>{items or "<li>No items pending.</li>"}</ul>
      </body>
    </html>
    """
    return HTMLResponse(content=html, status_code=200)


@router.get("/tenants/{tenant_id}")
def read_tenant(tenant_id: int):
    t = get_tenant(tenant_id)
    if not t:
        raise HTTPException(status_code=404, detail="Tenant not found")
    return t


@router.get("/tenants/{tenant_id}/teams")
def read_tenant_teams(tenant_id: int):
    t = get_tenant(tenant_id)
    if not t:
        raise HTTPException(status_code=404, detail="Tenant not found")
    teams = list_tenant_teams(tenant_id)
    return {"tenant_id": tenant_id, "teams": teams}







from fastapi import FastAPI, Depends, HTTPException, status, Header, Request, Header

def get_admin_key() -> str:
    return os.getenv("SENTINEL_ADMIN_KEY","")

async def require_admin(x_admin_key: str = Header(default="")):
    key = get_admin_key()
    if key and x_admin_key == key:
        return True
    raise HTTPException(status_code=403, detail="Forbidden")
app = FastAPI()
app.include_router(router_tenants)
def require_api_key(request: Request):
    ak = api_key()
    hdr = request.headers.get("X-API-Key")
    if not ak:
        # If no key configured, default to deny for safety
        raise HTTPException(status_code=503, detail="API key not configured")
    if hdr != ak:
        raise HTTPException(status_code=401, detail="Invalid or missing API key")
    return True
@app.get("/healthz")
def healthz():
    return {"ok": True, "rollback": is_rollback_enabled()}
@app.post("/admin/rollback")
def set_rollback_mode(payload: dict, request: Request):
    require_api_key(request)
    enabled = bool(payload.get("enabled", False))
    set_rollback(enabled)
    audit_log(f"rollback_mode set to {enabled} by remote={request.client.host}")
    return {"ok": True, "enabled": enabled}

@app.on_event("startup")
def _startup_banner():
    try:
        v = build_version()
    except Exception:
        v = "dev"
    try:
        audit_log(f"api startup version={v}")
    except Exception:
        print(f"[sentinel] startup version={v}")
@app.get("/healthz-plus")
def healthz_plus():
    v = build_version()
    db_ok = False
    try:
        db_ok = db.db_ping()
    except Exception:
        db_ok = False
    return {"ok": True, "rollback": is_rollback_enabled(), "db_ok": db_ok, "version": v}






# --- API key guard ---
def verify_api_key(x_api_key: str | None = Header(default=None, alias="X-API-Key"),
                   authorization: str | None = Header(default=None, alias="Authorization"),
                   request: Request = None):
    expected = get_api_key()
    token = None
    if authorization and authorization.lower().startswith("bearer "):
        token = authorization.split(" ",1)[1].strip()
    elif x_api_key:
        token = x_api_key.strip()
    if not expected or not token or token != expected:
        try:
            client = request.client.host if request and request.client else ""
            write_audit("auth_failed", 401, request.url.path if request else "", request.method if request else "", client, {"reason":"bad or missing key"})
        except Exception:
            pass
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Unauthorized")
    return True

@app.get("/healthz/live")
def health_live():
    return {"live": True}

@app.get("/healthz/ready")
def health_ready():
    try:
        e = get_engine()
        with e.connect() as conn:
            conn.execute(text("SELECT 1"))
        return {"ready": True}
    except Exception as ex:
        raise HTTPException(status_code=503, detail=f"not ready: {ex}")

@app.middleware("http")
async def _audit_middleware(request: Request, call_next):
    resp = None
    try:
        resp = await call_next(request)
        return resp
    finally:
        try:
            path = str(request.url.path)
            if path.startswith("/tenants/") and path.endswith("/enable"):
                client = request.client.host if request and request.client else ""
                status_code = resp.status_code if resp else 500
                write_audit("team_enable", status_code, path, request.method, client)
        except Exception:
            pass

@app.exception_handler(HTTPException)
async def _http_exception(request: Request, exc: HTTPException):
    try:
        path = str(request.url.path)
        if path.startswith("/tenants/") and path.endswith("/enable"):
            client = request.client.host if request and request.client else ""
            write_audit("team_enable", exc.status_code, path, request.method, client, {"error": str(exc.detail)})
    except Exception:
        pass
    # Re-raise default response
    from fastapi.responses import JSONResponse
    return JSONResponse(status_code=exc.status_code, content={"detail": exc.detail})

