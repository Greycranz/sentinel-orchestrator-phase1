from fastapi import FastAPI, Depends
from sentinel_engine.security import guard_api_key
from sentinel_engine.routes import agents, jobs, admin, llm

app = FastAPI(title="Sentinel Orchestrator")

@app.get("/healthz")
def healthz():
    return {"status": "ok"}

@app.get("/healthz/live")
def live():
    return {"status": "ok"}

@app.get("/healthz/ready")
def ready():
    return {"status": "ok"}

# Mount routers
app.include_router(agents.router, prefix="/agents", tags=["agents"], dependencies=[Depends(guard_api_key)])
app.include_router(jobs.router,   prefix="/jobs",   tags=["jobs"],   dependencies=[Depends(guard_api_key)])
app.include_router(admin.router,  prefix="/admin",  tags=["admin"])
app.include_router(llm.router,    prefix="/llm",    tags=["llm"],    dependencies=[Depends(guard_api_key)])

from fastapi import Request, Response
import time

# --- Metrics globals ---
metrics_data = {
    "requests_total": 0,
    "requests_by_path": {},
    "errors_total": 0,
    "start_time": time.time()
}

@app.middleware("http")
async def metrics_and_auth_middleware(request: Request, call_next):
    # Skip auth for health + metrics
    open_paths = ("/healthz", "/healthz/live", "/healthz/ready", "/metrics")
    path = request.url.path

    # Auth guard for non-open paths
    if not any(path.startswith(p) for p in open_paths):
        from .security import verify_api_key
        await verify_api_key(request)  # raises HTTPException if invalid

    # Metrics tracking
    metrics_data["requests_total"] += 1
    metrics_data["requests_by_path"].setdefault(path, 0)
    metrics_data["requests_by_path"][path] += 1

    try:
        response = await call_next(request)
        return response
    except Exception:
        metrics_data["errors_total"] += 1
        raise

@app.get("/metrics")
def metrics():
    """Basic Prometheus-style metrics"""
    uptime = time.time() - metrics_data["start_time"]
    lines = [
        f"# HELP sentinel_requests_total Total HTTP requests",
        f"# TYPE sentinel_requests_total counter",
        f"sentinel_requests_total {metrics_data['requests_total']}",
        f"# HELP sentinel_errors_total Total HTTP request errors",
        f"# TYPE sentinel_errors_total counter",
        f"sentinel_errors_total {metrics_data['errors_total']}",
        f"# HELP sentinel_uptime_seconds Service uptime in seconds",
        f"# TYPE sentinel_uptime_seconds gauge",
        f"sentinel_uptime_seconds {uptime}"
    ]
    for path, count in metrics_data["requests_by_path"].items():
        safe_path = path.replace("/", "_").strip("_")
        lines.append(f'sentinel_requests_path_total{{path="{path}"}} {count}')
    return Response("\n".join(lines), media_type="text/plain")

# ---------------- Teams minimal storage & endpoints (file-backed) ----------------
from fastapi import HTTPException
from typing import Dict, Any, List
import json, os, threading, time

_TEAMS_DATA_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "ops", "data")
_TEAMS_DATA_PATH = os.path.join(_TEAMS_DATA_DIR, "teams.json")
_AUDIT_LOG_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "ops", "logs")
_AUDIT_LOG_PATH = os.path.join(_AUDIT_LOG_DIR, "audit.jsonl")
_os_init_once = threading.Lock()

def _ensure_paths():
    with _os_init_once:
        os.makedirs(_TEAMS_DATA_DIR, exist_ok=True)
        os.makedirs(_AUDIT_LOG_DIR, exist_ok=True)
        if not os.path.exists(_TEAMS_DATA_PATH):
            with open(_TEAMS_DATA_PATH, "w", encoding="utf-8") as f:
                json.dump({}, f)

def _load_teams() -> Dict[str, Dict[str, Dict[str, Any]]]:
    _ensure_paths()
    try:
        with open(_TEAMS_DATA_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
            if not isinstance(data, dict):
                return {}
            return data
    except Exception:
        return {}

def _save_teams(data: Dict[str, Dict[str, Dict[str, Any]]]) -> None:
    _ensure_paths()
    tmp = _TEAMS_DATA_PATH + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, _TEAMS_DATA_PATH)

def _audit(event: str, payload: Dict[str, Any]) -> None:
    _ensure_paths()
    rec = {
        "ts": time.time(),
        "event": event,
        **payload
    }
    with open(_AUDIT_LOG_PATH, "a", encoding="utf-8") as f:
        f.write(json.dumps(rec) + "\n")

@app.get("/tenants/{tenant}/teams")
async def list_teams(tenant: str):
    """
    List teams for a tenant.
    """
    data = _load_teams()
    tenant_obj = data.get(tenant, {})
    # return as array
    result = [{"team": k, **v} for k, v in tenant_obj.items()]
    return {"tenant": tenant, "teams": result}

@app.post("/tenants/{tenant}/teams/{team}/enable")
async def enable_team(tenant: str, team: str, enabled: bool = True):
    """
    Upsert team enabled state for a tenant.
    """
    data = _load_teams()
    if tenant not in data:
        data[tenant] = {}
    team_obj = data[tenant].get(team, {})
    team_obj["enabled"] = bool(enabled)
    team_obj.setdefault("created_at", time.time())
    team_obj["updated_at"] = time.time()
    data[tenant][team] = team_obj
    _save_teams(data)

    _audit("team_enable", {"tenant": tenant, "team": team, "enabled": bool(enabled)})

    return {"tenant": tenant, "team": team, "enabled": bool(enabled)}
# ---------------- end Teams endpoints ----------------
